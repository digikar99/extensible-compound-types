
* Motivation

#+BEGIN_QUOTE
=extensible-compound-types= allows for the definition of user-defined [[http://www.lispworks.com/documentation/lw70/CLHS/Body/26_glo_c.htm#compound_type_specifier][compound-types]]. These work well with respect to type safety, but may not work completely well with respect to optimization.
#+END_QUOTE


Common Lisp has a rich (although not the richest :/) type system allowing for the combination of types using =not and or member values=, specifying =eql= types, or even completely arbitrary types using =satisfies=. 

Through [[http://www.lispworks.com/documentation/lw70/CLHS/Body/26_glo_c.htm#compound_type_specifier][compound-types]], it even allows for specification of the exact integer or float through =(num-type low high)=, or the exact dimensions of a vector or array through =(array-type element-type rank/dimensions)=. This allows compilers to type-check the code besides enhancing readability, besides also helping them with optimization. However, CLHS does not provide facilities for cleanly defining user-defined compound-types. Such types could include a =(equalp object)= type, a ~(type= type)~ , or a =(pair type-1 type-2)= type, or =(custom-array element-type dimensions)=. The most one can do is play around with =satisfies= types. However, not only do =satisfies= types not integrate well into rest of the type system, but they are restricted to single argument functions that only take the object to be type-checked as their argument.

=extensible-compound-types= allow for the definition of user-defined compound types. Unfortunately, this requires nothing less than shadowing the symbols in the CL package, since, one,

#+BEGIN_QUOTE
The consequences are undefined if decl-name is a symbol that can appear as the car of any standard declaration specifier.

The consequences are also undefined if the return value from a declaration handler defined with define-declaration includes a key name that is used by the corresponding accessor to return information about any standard declaration specifier. (For example, if the first return value from the handler is :variable, the second return value may not use the symbols dynamic-extent, ignore, or type as key names.)

-- [[https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node102.html][8.5 Environments, Common Lisp the Language, 2nd Edition]]
#+END_QUOTE

And two, one needs to convert the declarations into a type-check statement for purposes of correctness. Towards this, a =extensible-compound-types-cl= system and package is also provided that shadows symbols that incorporate declarations.

* Contents
:PROPERTIES:
:TOC:      :include all
:END:

:CONTENTS:
- [[#motivation][Motivation]]
- [[#contents][Contents]]
- [[#core-api-for-using-as-a-shadowing-package][Core API for using as a shadowing package]]
- [[#additional-tools][Additional tools]]
- [[#extensible-compound-types-api][Extensible Compound Types API]]
- [[#parametric-types][Parametric Types]]
- [[#needs-more-work][Needs more work]]
- [[#internal-discussion][Internal Discussion]]
  - [[#usage-api][Usage API]]
  - [[#shadowing-cl-package][Shadowing CL package]]
  - [[#handling-parametric-types][Handling parametric types]]
  - [[#integration-with-cltype-declarations][Integration with CL:TYPE declarations]]
  - [[#subtypep][subtypep]]
    - [[#if-two-types-are-such-that-one-type-has-a-greater-number-of-specified-parameters-than-another-then-should-that-mean-first-is-more-specialized-than-second][If two types are such that one type has a greater number of specified parameters than another, then should that mean first is more specialized than second?]]
    - [[#what-should-the-relations-between-two-compound-types-corresponding-to-subclass-and-superclass][What should the relations between two compound types corresponding to subclass and superclass?]]
  - [[#simplify-type-aka-typexpand][simplify-type aka typexpand]]
  - [[#only-specialized-types-or-more-general-compound-types-like-type-type][Only specialized types, or more general compound types like (type= type)?]]
  - [[#comparison-with-cl-parametric-types][Comparison with cl-parametric-types]]
  - [[#comparison-with-ctype][Comparison with ctype]]
:END:


* Core API for using as a shadowing package

- typep
- subtypep
- deftype
- check-type
- the
- unknown-type-specifier

* Additional tools

- undeftype
- typexpand-1
- typexpand
- typexpand-all
- type=
- supertypep
- intersect-type-p
- =*the-skip-predicates*=

* Extensible Compound Types API

- define-compound-type
- undefine-compound-type
- %upgraded-cl-type
- %subtypep
- %intersect-type-p
- extype

Compound Types can be defined by first defining the =typep= part using =define-compound-type=.

To use this type in a =(declare (extype ...))= declaration, one also needs to define the ANSI CL counterpart of the closest supertype of the given by specializing the =%upgraded-cl-type= generic-function. To play nice with =subtypep=, one needs to specialize the =%subtypep= generic-function. 

#+BEGIN_SRC lisp
  (defpackage extensible-compound-types-demo
    (:use :extensible-compound-types-cl))

  (in-package :extensible-compound-types-demo)

  (define-compound-type integer-multiples (object n)
    (and (numberp object)
         (zerop (rem object n))))

  (typep 5 '(integer-multiples 3)) ;=> NIL
  (typep 6 '(integer-multiples 3)) ;=> T

  (cl:defmethod %upgraded-cl-type ((name (eql 'integer-multiples)) type &optional env)
    (declare (ignore name env))
    'integer)

  (disassemble (lambda (x)
                 (declare (optimize speed)
                          (extype (integer-multiples 3) x))
                 x))
  ; disassembly for (COMMON-LISP:LAMBDA (X) :IN "/tmp/slime4RHup6")
  ; Size: 8 bytes. Origin: #x53AC4830                           ; (COMMON-LISP:LAMBDA
                                                                      (X)
                                                                    :IN
                                                                    "/tmp/slime4RHup6")
  ; 0:       488BE5           MOV RSP, RBP
  ; 3:       F8               CLC
  ; 4:       5D               POP RBP
  ; 5:       C3               RET
  ; 6:       CC10             INT3 16                           ; Invalid argument count trap

  ;; TODO: Add SUBTYPEP example
#+END_SRC

More examples for this can be found in the [[file:cl-compound-types.lisp][cl-compound-types.lisp]].

- TODO: Document shadowing CL package

* Parametric Types

Combined with [[https://github.com/digikar99/polymorphic-functions/][polymorphic-functions]], one can create a wrapper around =extensible-compound-types= as follows:

#+BEGIN_SRC lisp
  (ql:quickload "polymorphic-functions+extensible-compound-types")

  (cl:defpackage parametric-types-demo
    (:use :extensible-compound-types-cl :polymorphic-functions))

  (in-package :parametric-types-demo)

  (defstruct pair a b)

  (define-compound-type pair (o &optional (type-a 'cl:*) (type-b 'cl:*))
    (and (cl:typep o 'pair)
         (with-slots (a b) o
           (and (if (eq 'cl:* type-a)
                    t
                    (cl:typep a type-a))
                (if (eq 'cl:* type-b)
                    t
                    (cl:typep b type-b))))))

  (defmethod %upgraded-cl-type ((name (eql 'pair)) type &optional env)
    (declare (ignore type env))
    name)

  (defmethod %subtypep ((t1 (eql 'pair)) (t2 (eql 'pair)) type1 type2 &optional env)
    (declare (ignore t1 t2 env))
    (destructuring-bind (&optional (t1a 'cl:*) (t1b 'cl:*)) (rest type1)
      (destructuring-bind (&optional (t2a 'cl:*) (t2b 'cl:*)) (rest type2)
        ;; FIXME: This does not look exhaustive
        (cond ((and (eq t2a 'cl:*) (eq t2b 'cl:*))
               (values t t))
              ((and (eq t1a 'cl:*) (eq t2b 'cl:*))
               ;; t2a is specified, but t1a is not
               (values nil t))))))

  (defmethod %deparameterize-type ((car (eql 'pair)) type-specifier &optional env)
    (declare (ignore type-specifier env))
    car)

  (defmethod parametric-type-run-time-lambda-body ((type-car (eql 'pair)) type-cdr parameter)
    (let ((accessor (cond ((eq parameter (first type-cdr))
                           'pair-a)
                          ((eq parameter (second type-cdr))
                           'pair-b))))
      `(cl:lambda (pair)
         (declare (optimize speed)
                  (type pair pair))
         ;; FIXME: One needs a wrapper around TYPE-OF, since TYPE-OF may not
         ;; return what one expects; example:
         ;; (TYPE-OF 1) ;=> BIT
         (type-of (,accessor pair)))))

  (defmethod parametric-type-compile-time-lambda-body
      ((type-car (eql 'pair)) type-cdr parameter)
    `(cl:lambda (elt-type)
       (destructuring-bind (&optional (type-a t) (type-b t)) (rest elt-type)
         (declare (ignorable type-a type-b))
         (when (eq cl:* type-a) (setq type-a t))
         (when (eq cl:* type-b) (setq type-b t))
         ,(cond ((eq parameter (first type-cdr))
                 `type-a)
                ((eq parameter (second type-cdr))
                 `type-b)
                (t
                 (error "Unknown case"))))))

  (let ((*parametric-type-symbol-predicates*
          (list (lambda (s)
                  (let* ((name (symbol-name s))
                         (len  (length name)))
                    (and (char= #\< (elt name 0))
                         (char= #\> (elt name (1- len)))))))))
    (eval `(progn
             (define-polymorphic-function slot-a (object) :overwrite t)
             (defpolymorph slot-a ((o (pair <a> <b>))) <a>
               (pair-a o))
             (define-polymorphic-function slot-b (object) :overwrite t)
             (defpolymorph slot-b ((o (pair <a> <b>))) <b>
               (pair-b o)))))


  (disassemble (lambda (o)
                 (declare (extype (pair fixnum fixnum) o)
                          (optimize speed))
                 (cl:+ (pair-a o)
                       (pair-b o))))
  ;=> On SBCL: contains a call to GENERIC-+
  ; Size: 24 bytes. Origin: #x53AC4073                          ; (COMMON-LISP:LAMBDA
                                                                      (O)
                                                                    :IN
                                                                    "/tmp/slimei7txZd")
  ; 73:       488B4205         MOV RAX, [RDX+5]
  ; 77:       488B7A0D         MOV RDI, [RDX+13]
  ; 7B:       488BD0           MOV RDX, RAX
  ; 7E:       E85DCAF3FE       CALL #x52A00AE0                  ; GENERIC-+
  ; 83:       488BE5           MOV RSP, RBP
  ; 86:       F8               CLC
  ; 87:       5D               POP RBP
  ; 88:       C3               RET
  ; 89:       CC10             INT3 16                          ; Invalid argument count trap

  (disassemble (lambda (o)
                 (declare (extype (pair fixnum fixnum) o)
                          (optimize speed))
                 (cl:+ (slot-a o)
                       (slot-b o))))
  ;=> On SBCL: direct addition, without a call to GENRIC-+
  ; Size: 57 bytes. Origin: #x53AC4123                          ; (COMMON-LISP:LAMBDA
                                                                      (O)
                                                                    :IN
                                                                    "/tmp/slimeaort6N")
  ; 23:       488B4A05         MOV RCX, [RDX+5]
  ; 27:       F6C101           TEST CL, 1
  ; 2A:       752B             JNE L2
  ; 2C:       48D1F9           SAR RCX, 1
  ; 2F:       488B520D         MOV RDX, [RDX+13]
  ; 33:       F6C201           TEST DL, 1
  ; 36:       751C             JNE L1
  ; 38:       48D1FA           SAR RDX, 1
  ; 3B:       4801D1           ADD RCX, RDX
  ; 3E:       48D1E1           SHL RCX, 1
  ; 41:       7108             JNO L0
  ; 43:       48D1D9           RCR RCX, 1
  ; 46:       E805CEF3FE       CALL #x52A00F50                  ; ALLOC-SIGNED-BIGNUM-IN-RCX
  ; 4B: L0:   488BD1           MOV RDX, RCX
  ; 4E:       488BE5           MOV RSP, RBP
  ; 51:       F8               CLC
  ; 52:       5D               POP RBP
  ; 53:       C3               RET
  ; 54: L1:   CC4F             INT3 79                          ; OBJECT-NOT-FIXNUM-ERROR
  ; 56:       08               BYTE #X08                        ; RDX(d)
  ; 57: L2:   CC4F             INT3 79                          ; OBJECT-NOT-FIXNUM-ERROR
  ; 59:       04               BYTE #X04                        ; RCX(d)
  ; 5A:       CC10             INT3 16                          ; Invalid argument count trap
#+END_SRC

* TODO Needs more work 

- typelet
- typelet*
- Specifying better predicates for =*the-skip-predicates*=
  
* Internal Discussion

** Usage API

- cl-shadowing package: This should not do type-declaration-upgradation. This was an option earlier, because "why not". However, this cannot be done, because the part on type-declaration-upgradation can wreak havoc on user's expectations. For instance, below, one might expect =foo-caller= to compile successfully, but it does not:

  #+BEGIN_SRC lisp
    (define-polymorphic-function foo (a) :overwrite t)

    (defpolymorph foo ((x number)) number
      (setq x (coerce x 'single-float))
      (cl:+ x x))

    (defun foo-caller (b)
      (declare (optimize speed)
               (type fixnum b))
      (foo b))
  #+END_SRC


** Shadowing CL package

DEFAULT-THE-SKIP-PREDICATE

- Call a function TYPE-SAFE, if its guaranteed that at runtime, its arguments are of the type given by the compile time declarations, as well as the return values are of the appropriate types declared at compile time.
- Such TYPE-SAFE functions do not need a runtime type check, if its arguments are pre-tested to be of the appropriate types.
- Functions made by composing type-safe functions are type-safe. That is they do not require type checks. /(What is composing?)/

- Suppose we have a core set of type-safe functions. Then, functions that call these functions need not do any type checking of the return-values of the type-safe functions, if the declared return-types are a subtype of the caller's arguments parameter-type declarations.

** Handling parametric types
- unspecified parameters
- upgrading to non-parametric type

** Integration with CL:TYPE declarations
- Full typexpansion should produce CL:TYPE wherever possible for optimization purposes; TODO: specify "wherever possible".
- Should expand into CHECK-TYPE statements; CHECK-TYPE should not be redundant.
- If =:extensible-compound-types= in =cl:*features*=, then shadow =cl:type=.

- Do we reimplement /all/ the cl types listed on http://www.lispworks.com/documentation/lw70/CLHS/Body/04_bc.htm?

** subtypep

*** If two types are such that one type has a greater number of specified parameters than another, then should that mean first is more specialized than second?

No, because we also want to allow for types like ~(type= /type/)~.

*** What should the relations between two compound types corresponding to subclass and superclass?

Nothing. We are not implementing parametric types. We are implementing compound types.

** simplify-type aka typexpand

Might need to export =type-expander= and =(setf type-expander)= functionality.

** Only specialized types, or more general compound types like ~(type= /type/)~?

Allow for more general compound types.

** Comparison with cl-parametric-types

https://github.com/cosmos72/cl-parametric-types

We allow for more general types like ~(type= /type/)~.

** Comparison with ctype

Faster =typep= due to avoidance of =specifier-type=. TODO: Measure
